# Go语言基础

## Go语言介绍

### Go语言优势

* **可直接编译成机器码**，不依赖其他库，glibc 的版本有一定要求，部署就是扔一个文件上去就完成了。
* **静态类型语言**，但是有动态语言的感觉，静态类型的语言就是可以在编译的时候检查出来隐藏的大多数问题，动态语言的感觉就是有很多的包可以使用，写起来的效率很高。
* **语言层面支持并发**。再要支持并发的函数前加一个go即可。
* **内置 runtime，支持垃圾回收**，这属于动态语言的特性之一吧，虽然目前来说 GC(内存垃圾回收机制)不算完美，但是足以应付我们所能遇到的大多数情况，特别是 Go1.1 之后的 GC。
* **简单易学**，Go关键字是 25 个，但是表达能力很强大，几乎支持大多数你在其他语言见过的特性：继承、重载、对象等。
* **丰富的标准库**。几行代码就能写一个 性能优越的http server或tcp server。
* **内置强大的工具**，Go 语言里面内置了很多工具链，最好的应该是 gofmt 工具，自动化格式化代码，能够让团队 review 变得如此的简单，代码格式一模一样，想不一样都很困难。
* **跨平台编译**，如果你写的 Go 代码不包含 cgo，那么就可以做到 window 系统编译 linux的应用，如何做到的呢？Go 引用了 plan9 的代码，这就是不依赖系统的信息。
* **内嵌 C 支持**，Go 里面也可以直接包含 C 代码，利用现有的丰富的 C 库。

### Go语言应用场景

### Go命令工具

| 常用命令 | 用途                                                         |
| -------- | ------------------------------------------------------------ |
| build    | 用于编译给定的代码包或 Go 语言源码文件及其依赖包             |
| clean    | 用于清除执行其他 go 命令后遗留的目录和文件                   |
| doc      | 用于执行 go doc 命令以打印指定代码包                         |
| env      | 用于打印 Go 语言环境信息                                     |
| fix      | 用于执行 go tool fix 命令以修正给定代码包的源码文件中包含的过时语法和代码调用 |
| fmt      | 用于执行 go fmt 命令以格式化给定代码包中的源码文件           |
| get      | 用于下载和安装给定代码包及其依赖包                           |
| list     | 用于显示给定代码包的信息                                     |
| run      | 用于编译并运行给定的命令源码文件                             |
| install  | 编译包文件并编译整个程序                                     |
| test     | 用于测试给定的代码包                                         |
| tool     | 用于运行 Go 语言的特殊工具                                   |
| version  | 用于显示当前安装的 Go 语言的版本信息                         |

## Go命名规则

* Go 语言中的**函数名**、**变量名**、**常量名**、**类型名**、**语句标号**和**包名**等所有的命名，都遵循一个简单的命名规则：**一个名字必须以一个字母（Unicode 字母）或下划线开头**，后面可以跟任意数量的字母、数字或下划线。**大写字母和小写字母是不同的**，例如BubbleSort 和 bubbleSort 是两个不同的名字。

* Go 语言中类似 func 和 const 的关键字有 25 个(均为小写)。Go有大约 30 多个预定义的名字，比如 int 和 true 等，主要对应内建常量、内建类型、内建函数。**关键字和预定义的名字不能用于自定义名字，只能在特定语法结构中使用。**

  | 关键字   |             |        |           |        |
  | -------- | ----------- | ------ | --------- | ------ |
  | break    | default     | func   | interface | select |
  | case     | defer       | go     | map       | struct |
  | chan     | else        | goto   | package   | type   |
  | const    | fallthrough | if     | range     | switch |
  | continue | for         | import | return    | var    |

  | 内建常量 |       |      |      |
  | -------- | ----- | ---- | ---- |
  | true     | false | iota | nil  |

  | 内建类型 |         |         |            |           |
  | -------- | ------- | ------- | ---------- | --------- |
  | int      | int8    | int16   | int32      | int64     |
  | uint     | uint8   | uint16  | uint32     | uint64    |
  | uintptr  | float32 | float64 | complex128 | complex64 |
  | bool     | byte    | rune    | string     | error     |

  | 内建函数 |       |         |         |        |
  | -------- | ----- | ------- | ------- | ------ |
  | make     | len   | cap     | new     | append |
  | copy     | close | delete  | complex | real   |
  | imag     | panic | recover |         |        |

## Go的变量、匿名变量、常量

### 变量

#### 变量声明

* 变量相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据存储空间，之后可以通过引用变量名来使用这块存储空间。

* 变量声明

  ```go
  var v1 int
  var v2 int
  
  var v3, v4 int
  
  var (
      v5 int
      v6 int
  )
  ```

#### 变量初始化

```go
// 1
var v1 int = 10
// 2
var v2 = 10
// 3
v3 := 10
```

#### 变量赋值

```go
var v1 int
v1 = 123

//多重赋值
var v2, v3, v4 int
v2, v3, v4 = 1, 2, 3

// 互换
i := 10
j := 20
i, j = j, i
```

### 匿名变量

* _（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃

  ```go
  _, i, _, j := 1, 2, 3, 4
  
  func test()(int, string){
  	return 111, "Hello, World!"
  }
  // 丢弃111
  _, str := test()
  ```

### 常量与iota枚举

#### 常量定义

```go
// 1
const Pi float64 = 3.14
const zero = 0.0 // 自动类型推导
// 2
const(
    size int64 = 1024
    eof = -1 // 自动类型推导
)
// 3
const u, v float32 = 0, 3 // u = 0.0, v = 3.0
```

#### iota枚举

* 常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是**不用每行都写一遍初始化表达式**。

* 在一个 const 声明语句中，在第一个声明的常量所在的行，**iota 将会被置为 0**，然后在每一个**有常量声明的行加一**。

```go
const (
	x = iota // x == 0
	y = iota // y == 1
	z = iota // z == 2
	w // 这里隐式地说 w = iota，因此 w == 3。其实上面 y 和 z 可同样不用"= iota"
)

const v = iota // 每遇到一个 const 关键字，iota 就会重置，此时 v == 0

const (
	h, i, j = iota, iota, iota //h=0,i=0,j=0 iota 在同一行值相同
)

const (
	a = iota //a=0
	b = "B"
	c = iota //c=2
	d, e, f = iota, iota, iota //d=3,e=3,f=3
	g = iota //g = 4
)

const (
	x1 = iota * 10 // x1 == 0
	y1 = iota * 10 // y1 == 10
	z1 = iota * 10 // z1 == 20
)
```

## Go的基本数据类型与类型转换

### 基本数据类型

### 类型转换



## Go运算符

